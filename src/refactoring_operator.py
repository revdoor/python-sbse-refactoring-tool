"""
This module defines the RefactoringOperator class,
which are used to represent various refactoring operators that can be used
in SBSE process.
"""
import random
from abc import ABC, abstractmethod
from type_enums import RefactoringOperatorType, NodeType


def get_random_difference():
    return random.choice([-1, 0, 1])


def get_random_indicator(length):
    return random.randrange(1, length+1)


class RefactoringOperator(ABC):
    def __init__(
            self,
            *,
            operator_type,
            target_node_type,
            target_node_no,
            length=None,
            old_name=None,
            new_name=None,
            reference_node_no=None,
            start_idx=None,
    ):
        self.operator_type = operator_type
        self.target_node_type = target_node_type
        self.target_node_no = target_node_no
        self.length = length
        self.old_name = old_name
        self.new_name = new_name
        self.reference_node_no = reference_node_no
        self.start_idx = start_idx

    @abstractmethod
    def create_mutant(self):
        raise NotImplementedError

    def __str__(self):
        var_strs = [f"target={self.target_node_type.value}[{self.target_node_no}]"]

        if self.length is not None:
            var_strs.append(f"length={self.length}")

        if self.old_name is not None:
            var_strs.append(f"old_name={self.old_name}")

        if self.new_name is not None:
            var_strs.append(f"new_name={self.new_name}")

        if self.reference_node_no is not None:
            var_strs.append(f"reference={self.target_node_type.value}[{self.reference_node_no}]")

        if self.start_idx is not None:
            var_strs.append(f"start_idx={self.start_idx}")

        var_str = ", ".join(var_strs)

        return f"{self.operator_type.value}({var_str})"

    def __eq__(self, other):
        if not isinstance(other, RefactoringOperator):
            return False

        # do not compare the new_name, since it is generated by llm
        return (
            self.operator_type == other.operator_type and
            self.target_node_type == other.target_node_type and
            self.target_node_no == other.target_node_no and
            self.length == other.length and
            # self.new_name == other.new_name and
            self.reference_node_no == other.reference_node_no and
            self.start_idx == other.start_idx
        )

    def __hash__(self):
        return hash((
            self.operator_type,
            self.target_node_type,
            self.target_node_no,
            self.length,
            self.old_name,
            self.new_name,
            self.reference_node_no,
            self.start_idx,
        ))


class ExtractMethodOperator(RefactoringOperator):
    def __init__(self, target_node_typ, target_node_no, start_idx, length, new_name):
        assert target_node_typ in (
            NodeType.FunctionDef,
            NodeType.If,
            NodeType.For,
            NodeType.While
        )

        super().__init__(
            operator_type=RefactoringOperatorType.EM,
            target_node_type=target_node_typ,
            target_node_no=target_node_no,
            length=length,
            new_name=new_name,
            start_idx=start_idx
        )

    def create_mutant(self):
        new_node_type = self.target_node_type
        new_node_no = self.target_node_no
        new_start_idx = self.start_idx
        new_length = self.length

        match get_random_indicator(4):
            case 1:
                new_node_type += get_random_difference()
            case 2:
                new_node_no += get_random_difference()
            case 3:
                new_start_idx += get_random_difference()
            case 4:
                new_length += get_random_difference()

        return ExtractMethodOperator(new_node_type, new_node_no, new_start_idx, new_length, self.new_name)


class ExtractMethodWithReturnOperator(RefactoringOperator):
    def __init__(self, target_node_typ, target_node_no, start_idx, length, new_name):
        assert target_node_typ in (
            NodeType.FunctionDef,
            NodeType.If,
            NodeType.For,
            NodeType.While
        )

        super().__init__(
            operator_type=RefactoringOperatorType.EMR,
            target_node_type=target_node_typ,
            target_node_no=target_node_no,
            length=length,
            new_name=new_name,
            start_idx=start_idx
        )

    def create_mutant(self):
        new_node_type = self.target_node_type
        new_node_no = self.target_node_no
        new_start_idx = self.start_idx
        new_length = self.length

        match get_random_indicator(4):
            case 1:
                new_node_type += get_random_difference()
            case 2:
                new_node_no += get_random_difference()
            case 3:
                new_start_idx += get_random_difference()
            case 4:
                new_length += get_random_difference()

        return ExtractMethodWithReturnOperator(new_node_type, new_node_no, new_start_idx, new_length, self.new_name)


class RemoveDuplicateMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no, reference_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.RDM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            reference_node_no=reference_node_no
        )

    def create_mutant(self):
        new_node_no = self.target_node_no
        new_reference_node_no = self.reference_node_no

        match get_random_indicator(2):
            case 1:
                new_node_no += get_random_difference()
            case 2:
                new_reference_node_no += get_random_difference()

        return RemoveDuplicateMethodOperator(new_node_no, new_reference_node_no)


class RenameMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no, new_name):
        super().__init__(
            operator_type=RefactoringOperatorType.RM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            new_name=new_name
        )

    def create_mutant(self):
        new_node_no = self.target_node_no

        new_node_no += get_random_difference()

        return DecomposeConditionalOperator(new_node_no, self.new_name)


class RenameFieldOperator(RefactoringOperator):
    def __init__(self, target_node_no, old_name, new_name):
        super().__init__(
            operator_type=RefactoringOperatorType.RF,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            old_name=old_name,
            new_name=new_name
        )

    def create_mutant(self):
        new_node_no = self.target_node_no

        new_node_no += get_random_difference()

        return RenameFieldOperator(new_node_no, self.old_name, self.new_name)


class DecomposeConditionalOperator(RefactoringOperator):
    def __init__(self, target_node_no, new_name):
        super().__init__(
            operator_type=RefactoringOperatorType.DC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no,
            new_name=new_name
        )

    def create_mutant(self):
        new_node_no = self.target_node_no

        new_node_no += get_random_difference()

        return DecomposeConditionalOperator(new_node_no, self.new_name)


class ReplaceNestedConditionalOperator(RefactoringOperator):
    def __init__(self, target_node_no, length):
        super().__init__(
            operator_type=RefactoringOperatorType.RNC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no,
            length=length
        )

    def create_mutant(self):
        new_node_no = self.target_node_no
        new_length = self.length

        match get_random_indicator(2):
            case 1:
                new_node_no += get_random_difference()
            case 2:
                new_length += get_random_difference()

        return ReplaceNestedConditionalOperator(new_node_no, new_length)


class InlineMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.IM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no
        )

    def create_mutant(self):
        new_node_no = self.target_node_no

        new_node_no += get_random_difference()

        return InlineMethodOperator(new_node_no)


class ConsolidateConditionalExpressionOperator(RefactoringOperator):
    def __init__(self, target_node_no, length):
        super().__init__(
            operator_type=RefactoringOperatorType.CC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no,
            length=length
        )

    def create_mutant(self):
        new_node_no = self.target_node_no
        new_length = self.length

        match get_random_indicator(2):
            case 1:
                new_node_no += get_random_difference()
            case 2:
                new_length += get_random_difference()

        return ConsolidateConditionalExpressionOperator(new_node_no, new_length)


class ReverseConditionalExpressionOperator(RefactoringOperator):
    def __init__(self, target_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.RC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no
        )

    def create_mutant(self):
        new_node_no = self.target_node_no

        new_node_no += get_random_difference()

        return ReverseConditionalExpressionOperator(new_node_no)
