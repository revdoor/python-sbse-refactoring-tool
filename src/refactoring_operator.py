"""
This module defines the RefactoringOperator class,
which are used to represent various refactoring operators that can be used
in SBSE process.
"""

from abc import ABC
from type_enums import RefactoringOperatorType, NodeType


class RefactoringOperator(ABC):
    def __init__(
            self,
            *,
            operator_type,
            target_node_type,
            target_node_no,
            length=None,
            old_name=None,
            new_name=None,
            reference_node_no=None,
            start_idx=None,
    ):
        self.operator_type = operator_type
        self.target_node_type = target_node_type
        self.target_node_no = target_node_no
        self.length = length
        self.old_name = old_name
        self.new_name = new_name
        self.reference_node_no = reference_node_no
        self.start_idx = start_idx

    def __str__(self):
        var_strs = [f"target={self.target_node_type.value}[{self.target_node_no}]"]

        if self.length is not None:
            var_strs.append(f"length={self.length}")

        if self.old_name is not None:
            var_strs.append(f"old_name={self.old_name}")

        if self.new_name is not None:
            var_strs.append(f"new_name={self.new_name}")

        if self.reference_node_no is not None:
            var_strs.append(f"reference={self.target_node_type.value}[{self.reference_node_no}]")

        if self.start_idx is not None:
            var_strs.append(f"start_pos={self.start_idx}")

        var_str = ", ".join(var_strs)

        return f"{self.operator_type.value}({var_str})"

    def __eq__(self, other):
        if not isinstance(other, RefactoringOperator):
            return False

        # do not compare the new_name, since it is generated by llm
        return (
            self.operator_type == other.operator_type and
            self.target_node_type == other.target_node_type and
            self.target_node_no == other.target_node_no and
            self.length == other.length and
            # self.new_name == other.new_name and
            self.reference_node_no == other.reference_node_no and
            self.start_idx == other.start_idx
        )


class ExtractMethodOperator(RefactoringOperator):
    def __init__(self, target_node_typ, target_node_no, start_idx, length, new_name):
        assert target_node_typ in (
            NodeType.FunctionDef,
            NodeType.If,
            NodeType.For,
            NodeType.While
        )

        super().__init__(
            operator_type=RefactoringOperatorType.EM,
            target_node_type=target_node_typ,
            target_node_no=target_node_no,
            length=length,
            new_name=new_name,
            start_idx=start_idx
        )


class ExtractMethodWithReturnOperator(RefactoringOperator):
    def __init__(self, target_node_typ, target_node_no, start_idx, length, new_name):
        assert target_node_typ in (
            NodeType.FunctionDef,
            NodeType.If,
            NodeType.For,
            NodeType.While
        )

        super().__init__(
            operator_type=RefactoringOperatorType.EMR,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            length=length,
            new_name=new_name,
            start_idx=start_idx
        )


class RemoveDuplicateMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no, reference_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.RDM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            reference_node_no=reference_node_no
        )


class RenameMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no, new_name):
        super().__init__(
            operator_type=RefactoringOperatorType.RM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            new_name=new_name
        )


class RenameFieldOperator(RefactoringOperator):
    def __init__(self, target_node_no, old_name, new_name):
        super().__init__(
            operator_type=RefactoringOperatorType.RF,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no,
            old_name=old_name,
            new_name=new_name
        )


class DecomposeConditionalOperator(RefactoringOperator):
    def __init__(self, target_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.DC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no
        )


class ReplaceNestedConditionalOperator(RefactoringOperator):
    def __init__(self, target_node_no, length):
        super().__init__(
            operator_type=RefactoringOperatorType.RNC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no,
            length=length
        )


class InlineMethodOperator(RefactoringOperator):
    def __init__(self, target_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.IM,
            target_node_type=NodeType.FunctionDef,
            target_node_no=target_node_no
        )


class ConsolidateConditionalExpressionOperator(RefactoringOperator):
    def __init__(self, target_node_no, length):
        super().__init__(
            operator_type=RefactoringOperatorType.CC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no,
            length=length
        )


class ReverseConditionalExpressionOperator(RefactoringOperator):
    def __init__(self, target_node_no):
        super().__init__(
            operator_type=RefactoringOperatorType.RC,
            target_node_type=NodeType.If,
            target_node_no=target_node_no
        )
